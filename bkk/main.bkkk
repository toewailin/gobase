package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/mattn/go-isatty"
	"github.com/spf13/cobra"
)

// Constants for the CLI tool version and GitHub project template URL.
const CLI_VERSION = "0.2.0"
const GO_PROJECT_TEMPLATE_URL = "https://github.com/toewailin/go-project.git"

// Utility Functions for Colored Output
func colorize(colorCode, text string) string {
	if isTerminal() {
		return fmt.Sprintf("\033[%sm%s\033[0m", colorCode, text)
	}
	return text
}

func isTerminal() bool {
	return runtime.GOOS != "windows" && isatty.IsTerminal(os.Stdout.Fd())
}

func printInfo(message string) {
	fmt.Println(colorize("0;34", "INFO: "+message))
}

func printSuccess(message string) {
	fmt.Println(colorize("0;32", "SUCCESS: "+message))
}

func printError(message string) {
	fmt.Fprintln(os.Stderr, colorize("0;31", "ERROR: "+message))
	os.Exit(1)
}

// Check if Git is installed
func checkGitInstalled() bool {
	_, err := exec.LookPath("git")
	return err == nil
}

// Clone a Go project template from GitHub
func cloneRepo(projectName string) error {
	printInfo(fmt.Sprintf("Cloning Go project template from %s to %s...", GO_PROJECT_TEMPLATE_URL, projectName))
	cmd := exec.Command("git", "clone", "--depth", "1", GO_PROJECT_TEMPLATE_URL, projectName)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to clone repository: %w", err)
	}
	printSuccess("Project template cloned successfully!")

	// Remove the .git directory to make it a fresh project
	gitDir := filepath.Join(projectName, ".git")
	if _, err := os.Stat(gitDir); err == nil {
		printInfo(fmt.Sprintf("Removing .git directory from %s...", projectName))
		if err := os.RemoveAll(gitDir); err != nil {
			fmt.Fprintln(os.Stderr, colorize("0;31", fmt.Sprintf("WARNING: Failed to remove .git directory: %v", err)))
		} else {
			printSuccess("Removed .git directory.")
		}
	}
	return nil
}

// Update the module path in the go.mod file
func updateGoMod(projectName string) error {
	goModPath := filepath.Join(projectName, "go.mod")
	printInfo(fmt.Sprintf("Updating go.mod file in %s...", goModPath))

	data, err := ioutil.ReadFile(goModPath)
	if err != nil {
		return fmt.Errorf("failed to read go.mod file: %w", err)
	}

	// Update the module name in go.mod
	lines := strings.Split(string(data), "\n")
	updatedLines := make([]string, len(lines))
	replaced := false
	for i, line := range lines {
		if strings.HasPrefix(line, "module ") && !replaced {
			updatedLines[i] = fmt.Sprintf("module %s", strings.ToLower(strings.ReplaceAll(projectName, "-", "/")))
			replaced = true
		} else {
			updatedLines[i] = line
		}
	}
	updatedData := strings.Join(updatedLines, "\n")

	err = ioutil.WriteFile(goModPath, []byte(updatedData), 0644)
	if err != nil {
		return fmt.Errorf("failed to write updated go.mod file: %w", err)
	}

	printSuccess("go.mod updated successfully!")

	// Update the import paths in Go files
	err = updateImportPaths(projectName)
	if err != nil {
		return fmt.Errorf("failed to update import paths: %w", err)
	}

	printSuccess("Import paths updated successfully!")
	return nil
}

// Update import paths in Go files to reflect the project name
func updateImportPaths(projectName string) error {
	err := filepath.Walk(projectName, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			// Read the Go file
			data, err := ioutil.ReadFile(path)
			if err != nil {
				return fmt.Errorf("failed to read file %s: %w", path, err)
			}

			// Replace import paths
			updatedData := strings.ReplaceAll(string(data), "go-project", projectName)

			// Write the updated content back to the Go file
			err = ioutil.WriteFile(path, []byte(updatedData), 0644)
			if err != nil {
				return fmt.Errorf("failed to write file %s: %w", path, err)
			}
		}
		return nil
	})
	return err
}

// Run `go mod tidy` to clean up dependencies
func runGoModTidy(projectDir string) error {
	printInfo(fmt.Sprintf("Running 'go mod tidy' in %s...", projectDir))
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = projectDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to run 'go mod tidy': %w", err)
	}
	printSuccess("'go mod tidy' completed.")
	return nil
}

// Command to create a new Go project
var createProjectCmd = &cobra.Command{
	Use:   "new <project_name>",
	Short: "Create a new Go project from a template",
	Long:  `The 'new' command initializes a fresh Go project by cloning a template from GitHub and setting up the Go module.`,
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		projectName := args[0]

		if !checkGitInstalled() {
			return fmt.Errorf("git is not installed, please install git to clone the project")
		}

		// Check if target directory exists and is not empty
		targetDir, err := filepath.Abs(projectName)
		if err != nil {
			return fmt.Errorf("failed to get absolute path for directory '%s': %w", projectName, err)
		}

		if _, err := os.Stat(targetDir); err == nil {
			dir, err := os.Open(targetDir)
			if err != nil {
				return fmt.Errorf("could not open directory '%s': %w", targetDir, err)
			}
			defer dir.Close()

			_, err = dir.Readdirnames(1)
			if err == nil {
				return fmt.Errorf("target directory '%s' already exists and is not empty, please specify an empty or non-existent directory", targetDir)
			}
			printInfo(fmt.Sprintf("Directory '%s' exists but is empty. Proceeding with clone.", targetDir))
		} else if os.IsNotExist(err) {
			printInfo(fmt.Sprintf("Creating new directory: %s", targetDir))
			if err := os.MkdirAll(targetDir, 0755); err != nil {
				return fmt.Errorf("failed to create directory '%s': %w", targetDir, err)
			}
		} else {
			return fmt.Errorf("error checking directory '%s': %w", targetDir, err)
		}

		// Clone the project template into the specified directory
		if err := cloneRepo(projectName); err != nil {
			return err
		}

		// Update the go.mod file with the correct module name
		if err := updateGoMod(projectName); err != nil {
			return err
		}

		// Run `go mod tidy` in the new project directory
		if err := runGoModTidy(projectName); err != nil {
			return err
		}

		printSuccess("Project created successfully!")
		printInfo("To get started, navigate into the directory:")
		printInfo(fmt.Sprintf("  cd %s", projectName))
		printInfo("Then you can run your Go application!")
		return nil
	},
}

// Command to display the current version of goi
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show the current version of the goi CLI",
	Long:  `The 'version' command displays the current version of the goi command-line interface tool.`,
	Run: func(cmd *cobra.Command, args []string) {
		printSuccess(fmt.Sprintf("goi CLI version %s", CLI_VERSION))
	},
}

func main() {
	var rootCmd = &cobra.Command{
		Use:   "goi",
		Short: "goi is a CLI tool to manage Go projects",
		Long:  `goi is a command-line interface tool designed to streamline the creation, management, and deletion of Go projects.`,
	}

	// Add commands to the root command
	rootCmd.AddCommand(createProjectCmd)
	rootCmd.AddCommand(versionCmd)

	// Execute the root command
	if err := rootCmd.Execute(); err != nil {
		printError(fmt.Sprintf("Error executing command: %v", err))
	}
}
